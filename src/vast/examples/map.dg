export type Hashable = {! fun hash(): i32 !}

export type Missing = type { ...Error }

export type Map = <K: Hashable, V>{
    type Slot = { key: K, value: V }
    slots: (Slot | Missing)[] = []
    index: i32[][] = [defaultIndexSize; []]
    unused: i32[] = []

    fun `posfix[]`(key: K): var V | Missing {
        match find(key) {
            index: i32 -> yield return slots[index].value
            _ -> Missing { }
        }
    }

    fun add(key: K, value: V): V | Missing {
        match find(key) {
            index: i32 ->  match slots[index] {
                slot: Slot -> slot.value = value
                _ -> panic()
            }
            indexes: i32[] -> {
                indexes += slots.size
                slots += { :key, :value }
                Missing { }
            }
        }
    }

    fun remove(key: K): V | Missing {
        match find(key) {
            slot: var (Slot | Missing) ->
        }
    }

    fun sequence() = slots.sequence()

    fun keys(): K* {
        for slot in slots {
            match slot {
                slot: Slot -> yield slot.key
                else -> { }
            }
        }
    }

    fun values(): (var V)* {
        for slot in slots {
            match slot {
                slot: Slot -> yield slot.value
                else -> { }
            }
        }
    }

    private fun find(key: K) i32 | var i32[] {
        var indexes = indexesOf(key)
        for index in indexes {
            val slot = slots[index]
            if slot is Slot && slot.key == key {
                return index
            }
        }
        yield return indexes
    }

    private fun indexesOf(key: Key): var i32[] {
        yield return indexes[key.hash() % indexes.size]
    }
}

let defaultIndexSize = 32

